
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>Spring 트랜잭션 파헤치기 (0) 서론</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">Spring 트랜잭션 파헤치기 (0) 서론</h2>
                                <div class="box-info">
                                    <p class="category">탐구 생활/SpringBoot 파헤치기</p>
                                    <p class="date">2024-10-29 20:57:57</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><figure class="imageblock alignCenter" width="350" height="350" >
    <span data-lightbox="lightbox">
        <img src="./img/DALL&middot;E 2024-10-13 19.51.25 - A humorous illustration of someone physically digging into a large database structure, as if the database were a giant stack of data tables and SQL qu.webp" width="350" height="350"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">최근에 @Transactional 어노테이션이 붙어있는 메서드, 혹은 클래스의 메서드들이 어떻게 동작하는지 아냐는 물음을 받았다.</p>
<p data-ke-size="size16">그리고 나는 Spring 의 어떤 컴포넌트들이 데이터 베이스와 어떻게 상호작용하는지 알지 못한다는 것을 깨달았다.</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">반성하는 마음으로 Spring 의 Transaction에 대해서 파헤쳐보려고 한다.</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">이 글은 전반적으로 Spring 이 어떻게 <b>"데이터베이스 커넥션"</b>을 얻어와서 <b>"트랜잭션을 처리"</b>하는지 그 흐름을 다룬다.</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<h2 style="color: #333333; text-align: start;" data-ke-size="size26">데이터베이스 커넥션의 흐름</h2>
<p style="color: #333333; text-align: start;" data-ke-size="size16">Spring 은 Thread Pool 을 이용해서 효율적으로 요청을 처리한다고 알고 있을 것이다. 이것과 같은 개념으로 Spring 은 데이터 베이스에 대해서 Connection Pool 을 생성, 관리하여 효율적으로 데이터베이스 연결을 처리한다.</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 style="color: #333333; text-align: start;" data-ke-size="size26">트랜잭션의 흐름</h2>
<p style="color: #333333; text-align: start;" data-ke-size="size16">Spring 에서 데이터 베이스로부터 커넥션을 얻어오고 논리적인 트랜잭션 단위로 묶는 방법은 크게 2개가 존재한다. Annotation 을 이용한 방법과 직접 트랜잭션을 조작하는 방법이 그것이다. 그런데 주로 사용하는 방법이 Annotation 기반 방식이므로 이를 흐름을 알아보자</p>
<h3 style="color: #333333; text-align: start;" data-ke-size="size23">Annotation 기반</h3>
<p style="color: #333333; text-align: start;" data-ke-size="size16">Annotation 기반 트랜잭션 관리는 Spring에서 가장 일반적으로 사용되는 방식으로, 메소드나 클래스에 @Transactional 어노테이션을 적용하여 트랜잭션을 선언적으로 관리한다. 이 방식에서는 트랜잭션의 시작과 종료를 개발자가 명시적으로 제어할 필요가 없는 추상화된 트랜잭션 관리이다.</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16"><br />주요 클래스 및 동작 순서는 다음과 같다.</p>
<h4 style="color: #333333; text-align: start;" data-ke-size="size20">a. @Transactional</h4>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>트랜잭션을 관리할 메소드나 클래스에 적용하는 어노테이션이다.</li>
<li>이 어노테이션이 선언된 메소드가 호출되면, Spring은 해당 메소드를 프록시로 감싸서 트랜잭션 시작과 종료를 관리합니</li>
<li>propagation, isolation, timeout, readOnly 등의 속성을 설정하여 트랜잭션 동작을 제어할 수 있습니다.</li>
</ul>
<h4 data-ke-size="size20">b. TransactionInterceptor</h4>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>@Transactional이 적용된 메소드 호출 시 <b>실제 트랜잭션 동작을 처리</b>하는 인터셉터이다.</li>
<li>트랜잭션이 시작될 때, 인터셉터는 TransactionManager를 사용하여 트랜잭션을 시작하고, 메소드가 완료되면 트랜잭션을 커밋 또는 롤백한다.</li>
<li>이 인터셉터가 메소드 호출 전후로 <b>트랜잭션 경계를 설정</b>하는 역할을 한다.</li>
</ul>
<div style="background-color: #f0f0f0; padding: 16px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); border-radius: 8px;">
<p data-ke-size="size16"><b>*Spring MVC Interceptor 와 헷갈리지 않기</b></p>
<p data-ke-size="size16">Spring MVC 에는 Interceptor (더 정확하게는 <span style="background-color: #f0f0f0; color: #333333; text-align: start;">HandlerInterceptor) </span>라는게 존재한다. <span style="background-color: #f0f0f0; color: #333333; text-align: start;">Interceptor</span><span style="background-color: #f0f0f0; color: #333333; text-align: start;">&nbsp;</span>는 Handler Mapper 와 Hander Adaptor 사이에서 요청과 응답에 일정한 작업을 할 수 있는 기능을 말한다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그런데 여기서 나온 TranscationInterceptor 는 위에서 언급한 Interceptor 와는 무관하다. 이것은 <b>Spring AOP의 프록시 기반</b>으로 메서드 호출을 '가로채고' 트랜잭션을 시작하거나 커밋하는 역할을 수행하는데, 이러한 잉로 Intereceptor 라는 이름이 붙었다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">종종 Filter 와 Interceptor 를 비교하는데, 그에 대한 추가적인 내용이 궁금하다면 링크(<u>Todo</u>) 를 참고하자</p>
</div>
<p data-ke-size="size16">&nbsp;</p>
<h4 style="color: #333333; text-align: start;" data-ke-size="size20">c. PlatformTransactionManager</h4>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>Spring의 주요 트랜잭션 관리 인터페이스이다.</li>
<li>JDBC, JPA, Hibernate 등의 트랜잭션 전략을 구현할 수 있으며, 트랜잭션의 시작, 커밋, 롤백을 처리한다.</li>
<li>일반적으로 JPA 사용 시 JpaTransactionManager, JDBC 사용 시 DataSourceTransactionManager를 사용하게 된다.</li>
</ul>
<p data-ke-size="size16">&nbsp;</p>
<h4 style="color: #333333; text-align: start;" data-ke-size="size20">동작 순서</h4>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li>@Transactional이 적용된 메소드 호출 시, Spring의 AOP 프록시가 해당 메소드를 감지하고 TransactionInterceptor가 트랜잭션을 시작한다.</li>
<li>PlatformTransactionManager가 트랜잭션의 실제 시작을 처리하며, EntityManager 또는 Connection을 트랜잭션 범위 내에서 바인딩한다.</li>
<li>메소드가 실행되는 동안 트랜잭션이 유지되며, 데이터베이스 작업이 수행된다.</li>
<li>메소드가 정상적으로 종료되면 PlatformTransactionManager가 트랜잭션을 커밋하고, 예외가 발생할 경우 지정된 작업(롤백, 작업 취소) 를 수행한다.</li>
</ol>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size16">여담: 직접 트랜잭션 조작</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">혹시라도 AOP 기반이 아니라 직접 명시적으로 트랜잭션을 다뤄야하는 일이 생기지 않을까?</p>
<p data-ke-size="size16">이미 적절한 DataSource 가 바인되어있고, DataSource 가 하나라면 아래와 같은 방식으로 할 수 있다.</p>
<pre id="code_1730202982671" class="java" data-ke-language="java" data-ke-type="codeblock"><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

public class TransactionTest {

    @Autowired
    private PlatformTransactionManager transactionManager;

    @Autowired
    private SomeRepository someRepository; // 데이터베이스 작업을 수행할 레포지토리

    public void performTransactionalOperation() {
        // 트랜잭션 정의 설정
        DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
        definition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED); // 트랜잭션 격리 수준 설정
        definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); // 전파 수준 설정

        // 트랜잭션 상태 객체
        TransactionStatus status = transactionManager.getTransaction(definition);
        try {
            // 트랜잭션 내에서 데이터베이스 작업 수행
            someRepository.save(new SomeEntity(1));
            someRepository.save(new SomeEntity(2));

            // 모든 작업이 성공적으로 끝났으므로 트랜잭션 커밋
            transactionManager.commit(status);
        } catch (Exception e) {
            // 예외가 발생하면 트랜잭션을 롤백
            transactionManager.rollback(status);
            System.out.println("트랜잭션 롤백됨: " + e.getMessage());
        }
    }
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #spring 트랜잭션 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
