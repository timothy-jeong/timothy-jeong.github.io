
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>Spring 트랜잭션 파헤치기 (1) Transactional</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">Spring 트랜잭션 파헤치기 (1) Transactional</h2>
                                <div class="box-info">
                                    <p class="category">탐구 생활/SpringBoot 파헤치기</p>
                                    <p class="date">2024-10-29 20:59:25</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16">&nbsp;</p>
<p><figure class="imageblock alignCenter" width="350" height="350" >
    <span data-lightbox="lightbox">
        <img src="./img/DALL&middot;E 2024-10-13 19.51.25 - A humorous illustration of someone physically digging into a large database structure, as if the database were a giant stack of data tables and SQL qu.webp" width="350" height="350"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">AOP 기준으로 만들어진 트랜잭션 흐름을 순서대로 파고들어보자</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26">@Transactional 어노테이션에 대해서</h2>
<p data-ke-size="size16">이 어노테이션은 TransactionManger 를 통해 트랜잭션을 관리하는 선언적이고, <b><u>포괄적인 방법</u></b>을 제공한다.</p>
<div style="background-color: #f0f0f0; padding: 16px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); border-radius: 8px;">
<p data-ke-size="size16"><b>포괄적?</b></p>
<p data-ke-size="size16">이 어노테이션에 직접 TransactionManger 의 이름을 명시함으로써 관리하고자하는 트랜잭션의 주체를 달리할 수 있으며, 심지어 JPA 를 통해 연결한 DB와 JDBC 를 통해 연결한 DB 모두 이 어노테이션을 통해 관리할 수 있다.</p>
</div>
<p data-ke-size="size16">&nbsp;</p>
<h3 style="color: #000000; text-align: start;" data-ke-size="size23">@Transactional 어노테이션 활용</h3>
<p style="color: #000000; text-align: start;" data-ke-size="size16">@Transactional 을 열어보면서 아래와 같이 구성되어 있다.</p>
<div style="background-color: #2b2b2b; color: #a9b7c6;">
<pre class="java" data-ke-language="java"><code>@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
@Reflective
public @interface Transactional {
    @AliasFor("value")
    String transactionManager() default ""; // 트랜잭션 매니저
    Propagation propagation() default Propagation.REQUIRED; // 전파 수준
    Isolation isolation() default Isolation.DEFAULT; // 격리 수준
    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT; // 타임 아웃
    boolean readOnly() default false; // 읽기 전용
    Class&lt;? extends Throwable&gt;[] rollbackFor() default {}; // 롤백 예외 지정
    Class&lt;? extends Throwable&gt;[] noRollbackFor() default {}; // 롤백 안할 예외 지정
}</code></pre>
</div>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>transactionManager</b>:
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>트랜잭션 매니저를 명시적으로 지정할 수 있다.</li>
<li>Spring에서는 여러 트랜잭션 매니저(PaltformTransactionManager, ReactiveTransactionManager 등)가 등록될 수 있으며, 여기서 어떤 매니저를 사용할지 지정한다.</li>
<li>명시하지 않으면 가장 적절한 매니저가 자동으로 사용된다.</li>
</ul>
</li>
<li><b>readOnly</b>:
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>트랜잭션이<span>&nbsp;</span><b>읽기 전용</b>임을 트랜잭션 매니저에 전달한다.</li>
<li>데이터 수정 작업이 없는 경우 성능 최적화를 기대할 수 있다.</li>
<li>하지만 모든 트랜잭션 매니저가 이 힌트를 고려하는 것은 아니므로 주의가 필요하다.</li>
</ul>
</li>
<li><b>propagation (전파 수준)</b>:
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>밑에서 더 자세히 다룬다.</b></li>
</ul>
</li>
<li><b>isolation (격리 수준)</b>:
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>트랜잭션의<span>&nbsp;</span><b>격리 수준</b>은 여러 트랜잭션이 동시에 수행될 때, 각 트랜잭션이 다른 트랜잭션의 변경사항을 어느 정도까지 볼 수 있는지를 결정한다.</li>
<li>Spring에서 제공하는 격리 수준:
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>READ_UNCOMMITTED</b>: 다른 트랜잭션의 아직 커밋되지 않은 데이터도 읽을 수 있음 (dirty read 허용).</li>
<li><b>READ_COMMITTED</b>: 다른 트랜잭션이 커밋한 데이터만 읽을 수 있음 (기본값).</li>
<li><b>REPEATABLE_READ</b>: 동일한 트랜잭션 안에서는 동일한 데이터를 반복 조회해도 같은 결과를 보장.</li>
<li><b>SERIALIZABLE</b>: 가장 높은 격리 수준으로, 트랜잭션을 직렬화하여 순차적으로 수행.</li>
</ul>
</li>
<li>만약 지정되지 않는다면<span>&nbsp;</span><b>DEFAULT</b><span>&nbsp;</span>인데, 이는 연동된 Database 에 따라서 다르다.</li>
</ul>
</li>
<li><b>rollbackFor</b>:
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>기본 롤백 조건: RuntimeException 과 Error(Unchecked Exception) 에 대해서만 롤백을 한다.&nbsp;</li>
<li>기본 조건에 더해서 지정된 예외(또는 예외 클래스 이름)에 대해서는<span>&nbsp;</span><b>트랜잭션을 롤백</b><span>하도록 할 수 있다.</span></li>
<li>기본적으로 RuntimeException과 Error에 대해서만 롤백하지만, 여기서 명시적으로 롤백할 예외를 추가할 수 있다.</li>
</ul>
</li>
<li><b>noRollbackFor:</b>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>기본 롤백 조건: RuntimeException 과 Error(Unchecked Exception) 에 대해서만 롤백을 한다.</li>
<li>기본 롤백 조건에 지정된 예외(또는 예외 클래스 이름)에 대해서는<span>&nbsp;</span><b>롤백을 하지 않도록</b>&nbsp;한다.</li>
<li>기본적으로 RuntimeException이나 Error에 대해 롤백하지만, 특정 예외에 대해서는 롤백하지 않도록 설정할 수 있다.</li>
</ul>
</li>
</ol>
<h3 data-ke-size="size23">트랜잭션 전파(propagation)&nbsp;</h3>
<h4 data-ke-size="size20">트랜잭션 전파 개념</h4>
<p data-ke-size="size16">트랜잭션 전파란 이미 트랜잭션이 진행중일 때 추가 트랜잭션 진행을 어떻게 할지 결정하는 것이다.</p>
<p data-ke-size="size16">그렇다면 하나의 트랜잭션이 시작중일때 또 하나의 트랜잭션을 시작하는것도 가능할까? 답은 프레임워크에서 논리적으로 구현이 되었지만 물리(DB 커넥션)적으로는 구현되어 있지 않다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">스프링은 DB 커넥션을 시작할때 Connection 객체를 가져오는데, 이 Connection 객체가 물리적으로 하나의 DB 커넥션 단위를 나타낸다. 만약&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 style="color: #000000; text-align: start;" data-ke-size="size20">트랜잭션 전파(propagation)&nbsp; 예시</h4>
<p data-ke-size="size16">트랜잭션 전파는 7가지 옵션이 있지만 그 중에서 REQUIRED, REQUIREDS_NEW, 그리고 NESTED 가 가장 활용도가 높을것 같아서 예시를 만들어보기로 했다.</p>
<p data-ke-size="size16">&nbsp;</p>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>REQUIRED (기본값)</b>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li>동작: 이미 실행 중인 트랜잭션이 있으면 참여하고, 없으면 새 트랜잭션을 시작한다.</li>
<li>사용 상황: 대부분의 경우 적절한 설정이다.</li>
<li>예시: 서비스 계층에서 데이터 저장을 수행할 때.</li>
</ol>
</li>
<li><b>REQUIREDS_NEW</b>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li>동작: 항상 새로운 트랜잭션을 시작합니다. 기존 트랜잭션이 있더라도 일시 중지한다.</li>
<li>사용 상황: 이메일 전송처럼 메인 트랜잭션과 무관한 작업이 있을 때.</li>
<li>예시: <span style="color: #333333; text-align: left;">메인 트랜잭션이 실패해도 이 메서드는<span>&nbsp;</span></span><b>커밋</b>됩니다.</li>
</ol>
</li>
<li><b>NESTED</b>&nbsp;
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li>동작: <span style="color: #333333; text-align: left;">부모 트랜잭션 내부에<span>&nbsp;</span></span><b>중첩 트랜잭션</b>을 만듭니다. 부모가 롤백되면 자식도 롤백된다.</li>
<li>사용 상황: <span style="color: #333333; text-align: left;">동일한 트랜잭션 내에서 특정 작업만<span>&nbsp;</span></span><b>별도 관리</b>가 필요할 때.</li>
<li>예시: <b>배치 작업</b>에서 일부 단계만 개별적으로 롤백하고 싶을 때</li>
</ol>
</li>
</ol>
<p data-ke-size="size16">&nbsp;</p>
<h3 style="color: #000000; text-align: start;" data-ke-size="size23">@readOnly 그리고 성능향상</h3>
<p data-ke-size="size16">readOnly 를 명시하게 되면 일부 성능향상을 기대할 수 있다는 말들이 있다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #spring @transactional #spring 트랜잭션 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
