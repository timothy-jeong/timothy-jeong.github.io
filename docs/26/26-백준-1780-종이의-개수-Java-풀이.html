
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>백준 1780 종이의 개수 Java 풀이</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">백준 1780 종이의 개수 Java 풀이</h2>
                                <div class="box-info">
                                    <p class="category">알고리즘/문제 풀이</p>
                                    <p class="date">2024-11-01 11:02:03</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script>
<p><figure class="imageblock alignCenter" width="350" height="350" >
    <span data-lightbox="lightbox">
        <img src="./img/DALL&middot;E 2024-11-02 00.25.35 - A detailed illustration of an adult carefully cutting graph paper with a precision knife. The person is focused, using a ruler and cutting mat to ensu.webp" width="350" height="350"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<h2 data-ke-size="size26">문제</h2>
<p data-ke-size="size16"><span style="background-color: #ffffff; color: #555555; text-align: start;">N&times;N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1<span> 이 있는데, 하나의 숫자로만 이루어진 정사가형의 개수를 세어서 -1, 0, 1 순서로 출력하라</span></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #ffffff; color: #555555; text-align: start;"><span>출처 : <a href="https://www.acmicpc.net/problem/1780" target="_blank" rel="noopener&nbsp;noreferrer">https://www.acmicpc.net/problem/1780</a></span></span></p>
<h2 data-ke-size="size26">접근</h2>
<p data-ke-size="size16">이전에 풀었던 <a href="https://probehub.tistory.com/25" target="_blank" rel="noopener">백준 2630 색종이 만들기</a>의 조금 다른 버전의 문제이다.</p>
<p data-ke-size="size16">기본적으로 동일한데 종이를 4등분이 아닌 9등분을 한다는 사실과 -1, 0, 1 순서로 출력한다는 사실이 다르다.</p>
<p data-ke-size="size16">따라서 <span style="color: #333333; text-align: start;">백준 2630 색종이 만들기 문제를 조금더 확장성 있게 바꿔서 풀면 된다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #333333; text-align: start;">역시 시간 복잡도는 O(N^2) 이다.</span></p>
<h2 data-ke-size="size26">풀이</h2>
<pre id="code_1730426510875" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public class Main {
    private static int[][] BOARD;
    private static final int NEXT_SQUARE_COUNT = 9;
    private static final Map&lt;Integer, Integer&gt; COUNT = new TreeMap&lt;&gt;(){{
        put(-1, 0);
        put(0, 0);
        put(1, 0);
    }};

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        // 입력 초기화
        int N = Integer.parseInt(br.readLine());
        BOARD = new int[N][N];
        for (int i = 0; i &lt; N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j &lt; N; j++) {
                BOARD[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        // 분할,정복
        divideAndCount(0, 0, N, NEXT_SQUARE_COUNT);

        // 출력

        COUNT.forEach((key, count) -&gt; System.out.println(count));
    }

    private static void divideAndCount(int x, int y, int size, int divide) {
        if (isOneColor(x, y, size)) {
            COUNT.put(BOARD[x][y], COUNT.getOrDefault(BOARD[x][y], 0) + 1);
            return;
        }

        int sqrtDivide = (int) Math.sqrt(divide); // 가로/세로로 나누는 개수
        int newSize = size / sqrtDivide;          // 각 분할 영역의 크기

        // sqrtDivide 만큼 행과 열을 분할하여 재귀 호출
        for (int i = 0; i &lt; sqrtDivide; i++) {
            for (int j = 0; j &lt; sqrtDivide; j++) {
                divideAndCount(x + i * newSize, y + j * newSize, newSize, divide);
            }
        }
    }

    /**
     *
     * @param x BOARD 탐색 시작 행 INDEX
     * @param y BOARD 탐색 시작 열 INDEX
     * @param size i+size, j+size 까지 탐색
     * @return {true: 모두 같은 색상만 있음 ,false: 서로 다른 색상이 있음}
     */
    private static boolean isOneColor(int x, int y, int size) {
        int color = BOARD[x][y];
        for (int i = x; i &lt; x + size; i++) {
            for (int j = y; j &lt; y + size; j++) {
                if (color != BOARD[i][j]) {
                    return false;
                }
            }
        }
        return true;
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #백준 1780 #백준 1780 JAVA #백준 1780 java 풀이 #백준 종이의 개수 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
