
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>헷갈리는 이분탐색 (binary search)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">헷갈리는 이분탐색 (binary search)</h2>
                                <div class="box-info">
                                    <p class="category">알고리즘/개념 정리</p>
                                    <p class="date">2024-10-01 16:43:18</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><figure class="imageblock alignCenter" >
    <span data-lightbox="lightbox">
        <img src="./img/bs.jpeg"  />
    </span>
    <figcaption>출처: https://dev.to/techlearners/binary-search-algorithm-explained-2nn5</figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이분탐색은 아이디어는 쉬운데 구현에서 헷갈려서 글을 남겨놓는다.</p>
<h2 data-ke-size="size26">이분탐색 이란&nbsp;</h2>
<p data-ke-size="size16">이분 탐색(Binary Search)은 <b>정렬된 배열이나 리스트에서 특정 값을 효율적으로 찾기 위한 알고리즘</b>이다. 탐색 범위를 절반씩 줄여가며 원하는 값을 찾기 때문에, 시간 복잡도가 <b>O(log n)</b>으로 매우 효율적입니다.</p>
<h3 data-ke-size="size23">이분 탐색의 원리</h3>
<p data-ke-size="size16">이분 탐색은 다음과 같은 절차로 진행된다.</p>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>탐색 범위 설정</b>: 시작점(left)과 끝점(right)을 지정하여 탐색 범위를 정한다.</li>
<li><b>중간 값 계산</b>: left와 right의 중간 인덱스(mid)를 계산한다.</li>
<li><b>중간 값 비교</b>:
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li>중간 값이 찾고자 하는 값(target)과 같으면 탐색을 종료한다.</li>
<li>중간 값이 target보다 작으면 left = mid + 1로 탐색 범위를 중간 이후로 좁힌다.</li>
<li>중간 값이 target보다 크면 right = mid - 1로 탐색 범위를 중간 이전으로 좁힌다.</li>
</ol>
</li>
<li><b>반복</b>: 위 과정을<span style="background-color: #f3c000;"> <b>left &lt;= right</b> </span>조건을 만족할 때까지 반복한다. 탐색 범위가 없으면 값이 존재하지 않는 것이므로 종료한다.</li>
</ol>
<h3 data-ke-size="size23">이분 탐색의 조건</h3>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>데이터가 정렬되어 있어야 한다</b>: 이분 탐색은 탐색 범위를 절반씩 줄이기 때문에, <b>데이터가 오름차순 또는 내림차순으로 정렬</b>되어 있어야 한다.</li>
<li><b>인덱스를 통해 중간 값에 접근할 수 있어야 한다</b>: 배열이나 리스트처럼 <b>인덱스를 통해 임의의 위치에 접근 가능한 자료구조</b>에 적용할 수 있다.</li>
</ol>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li style="list-style-type: none;">&nbsp;</li>
</ul>
<h3 data-ke-size="size23">이분 탐색의 활용</h3>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>정렬된 배열에서의 값 찾기</b>: 가장 대표적인 사용 예시로, <b>정렬된 배열에서 특정 값의 존재 여부</b>를 빠르게 판단할 때 사용한다.</li>
<li><b>Lower Bound &amp; Upper Bound 찾기</b>:
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><b>Lower Bound</b>: 찾고자 하는 값보다 <b>크거나 같은 첫 번째 위치</b>를 찾는다.</li>
<li><b>Upper Bound</b>: 찾고자 하는 값보다 <b>큰 첫 번째 위치</b>를 찾는다.</li>
</ol>
</li>
<li><b>결과가 단조적으로 증가/감소하는 문제 해결</b>: 답이 될 수 있는 범위가 정해져 있고 그 범위 안에서 <b>특정 조건을 만족하는 값을 찾는 경우</b>에도 사용된다.</li>
</ol>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26">구현&nbsp;</h2>
<pre id="code_1727761389255" class="java" data-ke-language="java" data-ke-type="codeblock"><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BinarySearchExample {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 숫자 N과 S 입력 받기
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        int N = Integer.parseInt(st.nextToken());
        int S = Integer.parseInt(st.nextToken());

        // N개의 숫자 입력 받기
        int[] numbers = new int[N];
        st = new StringTokenizer(br.readLine(), " ");
        for (int i = 0; i &lt; N; i++) {
            numbers[i] = Integer.parseInt(st.nextToken());
        }

        // 배열을 정렬한다.
        Arrays.sort(numbers);

        // 이분 탐색을 통해 타겟 숫자 S의 인덱스 찾기
        int resultIndex = binarySearch(numbers, S);

        // 결과 출력
        System.out.println(resultIndex);
    }

    // 이분 탐색 메소드
    private static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;

        while (left &lt;= right) {
            int mid = left + (right - left) / 2; // 중간 인덱스 계산

            if (arr[mid] == target) {
                return mid; // 타겟 숫자를 찾은 경우
            } else if (arr[mid] &lt; target) {
                left = mid + 1; // 타겟 숫자가 더 크다면 오른쪽으로 이동
            } else {
                right = mid - 1; // 타겟 숫자가 더 작다면 왼쪽으로 이동
            }
        }

        return -1; // 타겟 숫자를 찾지 못한 경우
    }
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #이분탐색 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
