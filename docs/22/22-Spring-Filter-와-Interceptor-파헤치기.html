
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>Spring Filter 와 Interceptor 파헤치기</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">Spring Filter 와 Interceptor 파헤치기</h2>
                                <div class="box-info">
                                    <p class="category">탐구 생활/SpringBoot 파헤치기</p>
                                    <p class="date">2024-10-30 06:25:34</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><figure class="imageblock alignCenter" width="350" height="350" >
    <span data-lightbox="lightbox">
        <img src="./img/DALL&middot;E 2024-10-29 21.07.43 - A playful digital illustration showing two human-like characters representing 'Spring Filter' and 'Spring Interceptor' facing off in a tense yet humor.webp" width="350" height="350"  />
    </span>
    <figcaption>(그림 밑에 있는 메서드명과 각 객체의 이름은 무관하다.)</figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">Spring 에는 Filter 와 Inteceptor 가 존재한다. 닮은 듯 안닮은 둘에 대해서 평소에 알던 지식보다 조금 만 더 깊이 들어가서 알아보자</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26">알아보기</h2>
<h3 data-ke-size="size23">정의</h3>
<p data-ke-size="size16">우선 Filter 와 Interceptor 의 정의를 알아보자.</p>
<h4 data-ke-size="size20"><b>Filter</b></h4>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>Servlet 스펙</b>에 따른 컴포넌트로, 서블릿 컨테이너 레벨에서 HTTP 요청과 응답을 전처리 및 후처리할 수 있는 기능을 제공한다.</li>
<li>모든 요청에 대해 일괄적으로 전역 설정을 적용하거나, 인증 및 인코딩과 같은 전반적인 작업을 수행할 수 있다.</li>
<li>DispatcherServlet 이전에 실행되므로, Spring MVC의 Controller에 도달하기 전 요청을 다룬다.<b></b></li>
</ul>
<h4 data-ke-size="size20"><b>Interceptor</b></h4>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>Spring MVC 스펙</b>에 따른 컴포넌트로, Spring MVC의 HandlerMapping과 HandlerAdapter 사이에서 Controller의 메서드 호출 전후와 View 렌더링 전에 특정 작업을 수행한다.</li>
<li>특정 요청에 대해 세밀하게 전처리나 후처리 로직을 추가하거나, 인증, 로깅, 권한 검증 등의 작업을 처리할 수 있다.</li>
<li>DispatcherServlet 이후에 실행되므로, Spring MVC의 요청 처리 흐름에 더 가까이 위치하여 Handler(Controller 메서드) 정보에 접근할 수 있다.</li>
</ul>
<p data-ke-size="size16">정의에서는 명확한 차이점이 존재한다.</p>
<p data-ke-size="size16">1.&nbsp; Filter 는 DispatcherServlet 이전에 실행되므로, Spring MVC의 Controller에 도달하기 전 요청을 다룬다.</p>
<p data-ke-size="size16">2. Interceptor 는 HandlerMapping과 HandlerAdapter 사이에서 작업을 수행하여 Handler 정보에 접근할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23">구현</h3>
<p data-ke-size="size16">코드로서 구현은 완벽히 다르다.&nbsp;</p>
<h4 style="color: #000000; text-align: start;" data-ke-size="size20"><b>Filter</b></h4>
<pre id="code_1730204652675" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public class MyFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        // 요청 전처리
        chain.doFilter(request, response); // 다음 필터 또는 서블릿으로 요청 전달
        // 응답 후처리
    }
}</code></pre>
<h4 style="color: #000000; text-align: start;" data-ke-size="size20"><b>Interceptor</b></h4>
<pre id="code_1730204119544" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Component
public class MyInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // 요청 처리 전
        return true; // true를 반환하면 다음 인터셉터 또는 핸들러로 진행
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {
        // 요청 처리 후
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        // 요청 완료 후
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">코드 수준에서 보니 둘 사이에 주요한 차이점이 보인다.</p>
<p data-ke-size="size16">1. Filter 는 ServletRequest, ServletResponse 를 다루고 chain 을 이용한다.&nbsp;</p>
<p data-ke-size="size16">2. Interceptor 는 HttpServletRequest, HttpServletResponse 를 다루고 Object 타입으로 매핑된 handler 와 ModelAndView 그리고 Exception 등이 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그런데 솔직히 말해서 이정도만 살펴봐도 둘이 너무 비슷하다. 그냥 할 수 있는 일도 사실상 똑같은게 아닐까? <b>그래서 뭐가 다른건데?</b> 라는 물음에 도움이 된 블로그는 망나니 개발자님의 <a href="https://mangkyu.tistory.com/173" target="_blank" rel="noopener">블로그 글</a>이었다. 하지만 이렇게 정리가 잘된 글 조차도 기본적인 배경 지식이 없으면 이해가 안될 수 있다. 자세히 다뤄보자</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26">그래서 뭐가 다른건데?</h2>
<h3 data-ke-size="size23">1. 둘다 Bean 을 활용 할 수 있다.</h3>
<p data-ke-size="size16">Filter 는 Spring 프레임워크 외부에서 동작한다는 사실은 정말 중요한 차이점이다. 그리고 이에 따라 Filter 에서는 Bean 을 못 쓰겠겠다 생각 할 수 있다. 이는 반만 맞고 반은 틀리다. 정확히 말하면<span style="background-color: #f6e199;"><b> Filter 에서는 Bean 을 '직접적'으로 활용할 수 없지만 '간접적' 으로 활용</b></span>할 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">"Bean 을 활용" 한다는 것은 Filter 가 Bean 으로 등록된다는 것을 의미한다. 언뜻 생각하면 Serlvet Spec 인 Filter 가 Spring Container 에 등록된다는건 상식으로 말이 안된다. 하지만 DI Container Spring 의 DeligatingFilterProxy 의 등장으로 Filter 도 Bean 으로 활용이 가능해졌다. (SpringBoot 에서는 Filter 에 그냥 @Component 에노테이션을 붙이면 활용 가능하다.)</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23">2. Hander 정보 접근은 정말 큰 차이다.</h3>
<p data-ke-size="size16">Interceptor 는 Handler 정보에 접근할 수 있다고 했다. 이로인해 어떤 차이점이 생기고 어떻게 접근하는지 알아보자.</p>
<p data-ke-size="size16">정의에서 보면 Filter 는 '전역적인 처리'&nbsp; 가 가능하고 Interceptor 는&nbsp; '특정 요청에 대해 세밀하게 처리' 가 가능하다고 했다. 이런 차이가 발생하는 이유가 Handler 정보에 접근하기 때문이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">아래와 같이 Interceptor 에서 핸들러(컨트롤러) 정보에 접근할 수 있다. 이러한 정보 접근을 통해 특정 메서드에 특정 행위를 할 수 있도록 '세밀하게' 처리할 수 있다.</p>
<pre id="code_1730337095347" class="java" data-ke-language="java" data-ke-type="codeblock"><code>@Component
public class MyInterceptor implements HandlerInterceptor {
    private static final Logger log = LoggerFactory.getLogger(MyInterceptor.class);
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        log.info("requestId: "+ request.getRequestId());
        if (handler instanceof HandlerMethod handlerMethod) {

            // Controller 클래스 정보
            Class&lt;?&gt; controllerClass = handlerMethod.getBeanType();
            log.info("Controller 클래스: " + controllerClass.getName());

            // Controller 메서드 정보
            Method method = handlerMethod.getMethod();
            log.info("Controller 메서드: " + method.getName());

            // 메서드의 파라미터 정보
            MethodParameter[] methodParameters = handlerMethod.getMethodParameters();
            log.info("메서드 파라미터: " + Arrays.toString(methodParameters));

            // 어노테이션 정보 접근 가능 (예: @Debug 등)
            if (handlerMethod.hasMethodAnnotation(Debug.class)) {
                log.info("debug log...");
            }
        }
        return true;
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<div style="background-color: #f0f0f0; padding: 16px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); border-radius: 8px;">
<p data-ke-size="size16">*HandlerInterceptor 에서 파라미터 조작</p>
<p data-ke-size="size16">Mehod, 그리고 MethodParameter 에 접근할 수 있다. 그리고 이 객체들은 Reflection 에 속해있거나 Reflection 을 활용화는 객체이기 때문에 Interceptor 수준에서 이용하여 파라미터, Body 값을 조작하는 작업을 생각할 수 있다.</p>
<p data-ke-size="size16">하지만 HttpServletRequest 를 기본적으로 불볍객체로 취급하기 때문에 이러한 rule 을 깨는 것은 에상치못한 결과를 초래할 수 있으며 협업에 있어서도 좋지않다.</p>
</div>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23">3. Filter 에서의 Exception 은 ExceptionHandler 를 거치지 않는다.</h3>
<p data-ke-size="size16">Filter 는 Spring 프레임워크 외부에서 동작한다는 사실로 인해 Filter 에서는 ExceptionHandler 가 동작하지 못한다.&nbsp; 간단하게 알아보자&nbsp;</p>
<p data-ke-size="size16"><br />Filter 수준에서 발생하는 Exception 으로는 다음을 생각해볼 수 있다.</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>HTTP URI 가 너무 클때&nbsp; HttpMessageNotReadableException</li>
<li>Content-Type 이 일치하지 않을때 발생하는 ContentTypeMismatchException</li>
</ul>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26">실제 활용</h2>
<p data-ke-size="size16">Filter 의 전역처리, Interceptor 의 세부적인 처리를 모두 활용할 수 있는 좋은 사례는 Logging 이라고 생각한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
