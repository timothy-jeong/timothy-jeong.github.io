
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>백준 11401 이항 계수 3 Java 풀이</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">백준 11401 이항 계수 3 Java 풀이</h2>
                                <div class="box-info">
                                    <p class="category">알고리즘/문제 풀이</p>
                                    <p class="date">2024-11-03 11:39:01</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script>
<p><figure class="imageblock alignCenter" width="350" height="350" >
    <span data-lightbox="lightbox">
        <img src="./img/DALL&middot;E 2024-11-02 08.16.08 - A simple, humorous illustration of a stick figure (stickman) choosing between two options. The stick figure is standing in front of two clearly marked.webp" width="350" height="350"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<h2 data-ke-size="size26">문제</h2>
<p data-ke-size="size16">n 개중에 k 개를 고르는 이항계수(Binomial Coefficient) 를 구하는 문제이다. 결과값을 1,000,000,007 로 나눈 나머지를 출력한다.</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">제약사항: 1 &lt;= n &lt;= 4,000,000, 0 &lt;= k &lt;= n</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">&nbsp;</p>
<p style="color: #333333; text-align: start;" data-ke-size="size16">출처:<span>&nbsp;</span><a href="https://www.acmicpc.net/problem/11051">https://www.acmicpc.net/problem/11401</a></p>
<h2 data-ke-size="size26">접근</h2>
<h3 data-ke-size="size23"><b>OutOfMemoryError: Java heap space</b></h3>
<p data-ke-size="size16">일단 숫자가 심상치 않게 크다는 것을 알 수 있다. 이항 계수 2에서 사용했던 이항 계수의 정의를 이용한 풀이를 하려면&nbsp; 4,000,000 * 4,000,000 의 long 타입 heap 메모리 공간(<b><span style="color: #333333; text-align: start;"><span>&nbsp;</span></span></b><span style="background-color: #ffffff; color: #1f1f1f; text-align: start;"><b>256,000 GB</b><span>&nbsp;</span></span>)을 확보해야한다.</p>
<p data-ke-size="size16">이정도의 heap 메모리 공간을 일반적인 컴퓨터에게 기대할 수 없는 수준이므로 4,000,000 * 16byte = <b>0.064GB</b>&nbsp; 의 메모리 공간을 요구하는 <span style="background-color: #ffffff; color: #1f1f1f; text-align: start;"><b>조합의 정의를 이용한 접근을 활용</b>해야한다.</span><span style="background-color: #ffffff; color: #1f1f1f; text-align: start;"></span></p>
<h3 data-ke-size="size23"><b><span style="background-color: #ffffff; color: #1f1f1f; text-align: start;">기존 모듈러 연산의 한계</span></b></h3>
<p data-ke-size="size16"><span style="background-color: #ffffff; color: #1f1f1f; text-align: start;"><a href="https://probehub.tistory.com/27" target="_blank" rel="noopener">이항 계수 1 풀이</a>에서 조합의 정의를 이용한 풀이를 보자</span></p>
<pre id="code_1730599794978" class="java" data-ke-language="java" data-ke-type="codeblock"><code>import java.util.Scanner;

public class Main {
    private static final int[] CACHE = new int[11];
    public static void main(String[] args) {
        CACHE[0] = 1;
        CACHE[1] = 1;
        CACHE[2] = 2;
        CACHE[3] = 6;
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();

        System.out.println(factorial(N) / (factorial(N-K) * factorial(K)));
    }

    private static int factorial(int num) {
        if(CACHE[num] != 0) {
            return CACHE[num];
        }
        CACHE[num] = (CACHE[num-1] == 0 ? factorial(num-1) : CACHE[num-1]) * num;
        return CACHE[num];
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><a href="https://probehub.tistory.com/28" target="_blank" rel="noopener">이항 계수 2 풀이</a> 에서 알아봤던 모듈러 연산 특징은 다음과 같았다.</p>
<div style="background-color: #f0f0f0; padding: 16px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1); border-radius: 8px;">
<p data-ke-size="size16">모듈러 연산의 특징</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>덧셈에 대한 모듈러</b>: <span><span>(a+b) %&thinsp;&thinsp;m =((a %&thinsp;m) + (b %&thinsp;&thinsp;m)) %&thinsp;&thinsp;m</span></span></li>
<li><b>곱셈에 대한 모듈러</b>: <span><span>(a*b) %&thinsp;&thinsp;m =((a %&thinsp;m) * (b %&thinsp;&thinsp;m)) %&thinsp;&thinsp;m</span></span></li>
</ul>
</div>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">하지만 여기서 어떻게 모듈러 연산을 적용할지 감이 오지 않는다.</p>
<p data-ke-size="size16">각 팩토리얼 연산마다 곱셈에 대한 모듈러 연산을 적용해야하나?</p>
<p data-ke-size="size16">하지만 최종적으로 팩토리얼 연산 결과간 나눗셈이 일어나는데 그때도 이 법칙이 유효한가?&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23">페르마의 소정리</h3>
<p data-ke-size="size16">이떄 등장하는게 페르마의 소정리이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">페르마의 소정리 자체는 간단하다.</p>
<p data-ke-size="size16"><b>&nbsp;어떤 소수 p와 p로 나누어떨어지지 않는 정수 a에 대해 (a^{p-1}) &equiv; 1 (mod p) 이 성립한다.&nbsp;</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">즉 p = 7, a = 3 일때 (3^6) = <span style="background-color: #ffffff; color: #1f1f1f; text-align: start;">729 이고, 729 mod 7 은 1 이 항상 성립한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="background-color: #ffffff; color: #1f1f1f; text-align: start;">이 성질을 어떻게 이용할 수 있을까?</span></p>
<p data-ke-size="size16">1. 어떠한 실수에 대해 a / b 를 구하기 위해서는 b 의 역원 (b^{-1}) 을 활용할 수 있다는 사실을 알고 있다.</p>
<p data-ke-size="size16"><span style="color: #333333; text-align: start;">2. 그렇다면 우리는 역원을 이용하여 나눗셈이 있는 식에 대해서<span>&nbsp;</span></span><b>곱셈에 대한 모듈러</b>를 적용할 수 있다.</p>
<p data-ke-size="size16">3. 페르마 소정리에 의해 역원은 <b>(a^{p-1}) &equiv; 1 -&gt; <b>(a^{p-2}) &equiv; (a^{-1})</b></b> 이 성립한다.</p>
<p data-ke-size="size16">4. n!/(n-k!)*k! 식에 대해서 우리는 (n-k!)*k! 에 대한 역원을 구해서 n! * ((n-k!^{p-2})) * ((k!^{p-2})) 로 계산하면 된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">다만 이러한 풀이가 성립하려면 mod 에 적용되는 값이 소수여야 한다. 다행히 주어진 mod 값은 소수이다.</p>
<h2 data-ke-size="size26">풀이</h2>
<pre id="code_1730601346073" class="java" data-ke-language="java" data-ke-type="codeblock"><code>import java.util.Scanner;

public class Main {
    private static final int MOD = 1_000_000_007;
    private static final int SIZE = 4_000_000;
    private static final long[] factorial = new long[SIZE + 1];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();

        // MOD 를 적용한 팩토리얼 값 미리 계산
        computeFactorials();

        // 이항 계수 계산
        long result = (factorial[N] * modInverse(factorial[K]) % MOD) * modInverse(factorial[N - K]) % MOD;
        System.out.println(result);
    }

    private static void computeFactorials() {
        factorial[0] = 1;
        for (int i = 1; i &lt;= SIZE; i++) {
            factorial[i] = (factorial[i - 1] * i) % MOD; // 모듈러 곱셉
        }
    }

    // 모듈러 역원 계산 (페르마의 소정리 이용)
    private static long modInverse(long x) {
        return pow(x, MOD - 2);
    }

    // 거듭제곱 분할 정복으로 x^y % MOD 계산
    private static long pow(long x, int y) {
        long result = 1;
        long base = x;

        while (y &gt; 0) {
            if (y % 2 != 0) {
                result = (result * base) % MOD;
            }
            base = (base * base) % MOD;
            y /= 2;
        }
        return result;
    }
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #백준 11401 #백준 11401 java #백준 11401 이항 계수 3 #백준 이항 계수 3 java 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
